{"version":3,"sources":["components/hud/HUDButton.js","pages/hud/HUDMainMenu.js","utils/SpotifyServiceTools.js","utils/SpotifyService.js","components/hud/HUDSearchBar.js","utils/StringTools.js","components/hud/SpotifySongListItem.js","pages/hud/HUDSongSearchMenu.js","pages/App.js","index.js"],"names":["HUDButtonTypesEnum","Object","freeze","HUDButton","props","type","text","onClick","filteredType","values","findIndex","element","SMALL","className","event","buttonType","defaultProps","console","error","HUDMainMenu","hasLoggedIn","onSongSelectRequest","onLoginRequest","onAboutPageRequest","onLeaderboardsPageRequest","spotifyLoginButton","selectSongButton","aboutButton","leaderboardsButton","mainButton","Error","log","state","body","message","notifier","notification","next","getTokensFromQuery","urlParams","URLSearchParams","window","location","search","accessToken","get","refreshToken","processTokens","refreshTokenFunction","stateNotifier","queryTokens","localStorage","setItem","localStorageRefreshToken","getItem","then","json","DEBUG_URL","SpotifyService","spotifyPlayerName","$cdn","Rx","BehaviorSubject","$sdk","$token","$spotifyServiceStateNotifier","ReplaySubject","combineLatest","cdnLoaded","sdkLoaded","tokenLoaded","filter","isAllLoaded","subscribe","player","Player","Spotify","callback","connect","addListener","device_id","initPlayer","this","getNewAccessToken","notif","newState","name","spotifyStateNotifier","fromCDN","onSpotifyWebPlaybackSDKReady","tokenToBeUsed","fetch","response","catch","getCurrentState","play","track_window","current_track","next_track","togglePlay","uri","spotifyURI","getOAuthToken","id","access_token","details","JSON","stringify","searchQueryString","index","limit","url","header","err","HUDSearchBar","defaultTextValue","lastSubmittedValue","autoSearchTimer","handleChange","bind","handleSubmit","clearTimeout","setTimeout","setState","target","value","searchSongsWithQuery","string","letters","trim","match","words","curWord","forEach","letter","length","push","wordsToArray","onChange","ENTER","Component","query","SpotifySongListItem","imgURL","artist","handleClick","src","arr","str","renderArtistArray","HUDSongSearchMenu","spotifyService","filterReceivedJSON","items","dotProp","newTrackArray","map","item","img","createTrackObject","songList","hasSearched","song","key","input","renderSongList","APP_NAME","App","currentMenu","login","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.cc8aba8a.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"../../css/hud/HUDButton.css\";\n\n/**\n * Enumeration that defines types of button CSS layouts supported. Buttons instantiated without\n * a type will default to SMALL.\n * This value is emitted along with the original click event.\n * @type {Readonly<{RETURN: string, SMALL: string, LARGE: string, ENTER: string}>}\n */\nexport const HUDButtonTypesEnum = Object.freeze({\n    \"SMALL\": \"hud-button-small\",\n    \"LARGE\": \"hud-button-large\",\n    \"RETURN\": \"hud-button-return\",\n    \"ENTER\": \"hud-button-enter\"\n});\n\n/**\n * Wrapper for HTML Button element. Sanitizes button text and has preset styles.\n * Emits button type on click.\n *\n * @param {Object} props React properties\n * @returns {React.Component} JSX element\n * @constructor\n */\nconst HUDButton = props => {\n\n    // props\n    const {\n        type,\n        text,\n        onClick\n    } = props;\n\n    // check if passed type exists\n    const classes = Object.values(HUDButtonTypesEnum);\n    const isValidType = classes.findIndex(element => element === type) !== -1;\n    const filteredType = isValidType ? type : HUDButtonTypesEnum.SMALL;\n\n    // return jsx\n    return (\n        <button\n            className={`${filteredType} hud-button`}\n            onClick={(event => {\n                event.buttonType = filteredType;\n                onClick(event);\n            })}\n        >\n            {text}\n        </button>\n    );\n\n};\n\n// prop types for development\nHUDButton.propTypes = {\n    \"type\": PropTypes.string,\n    \"text\": PropTypes.string,\n    \"onClick\": PropTypes.func\n};\n\n// default props\nHUDButton.defaultProps = {\n    \"type\": HUDButtonTypesEnum.SMALL,\n    \"text\": \"Button Text Not Set\",\n    \"onClick\": () => console.error(\"Click handler not set for this button.\")\n};\n\nexport default HUDButton;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport HUDButton from \"../../components/hud/HUDButton\";\nimport \"../../css/hud/HUDMainMenu.css\";\n\n/**\n * HUD element that wraps all objects in main menu. Two types of main menu can exist:\n * pre and post login.\n * @param {Object} props react props\n * @constructor\n */\nconst HUDMainMenu = props => {\n\n    const {\n        hasLoggedIn,\n        onSongSelectRequest,\n        onLoginRequest,\n        onAboutPageRequest,\n        onLeaderboardsPageRequest\n    } = props;\n\n    // // // BUTTONS // // //\n    const spotifyLoginButton = <HUDButton\n        text=\"Spotify Login\"\n        onClick={onLoginRequest}\n    />;\n\n    const selectSongButton = <HUDButton\n        text=\"Select Song\"\n        onClick={onSongSelectRequest}\n    />;\n\n    const aboutButton = <HUDButton\n        text=\"About\"\n        onClick={onAboutPageRequest}\n    />;\n\n    const leaderboardsButton = <HUDButton\n        text=\"Leaderboards\"\n        onClick={onLeaderboardsPageRequest}\n    />;\n\n    // determines which top button will be rendered\n    const mainButton = hasLoggedIn ? selectSongButton : spotifyLoginButton;\n\n    return (\n\n        <div className=\"hud-main-menu-outer-container\">\n            <div className=\"hud-main-menu-button-container\">\n                {mainButton}\n                {aboutButton}\n                {leaderboardsButton}\n            </div>\n        </div>\n\n    );\n\n};\n\n// prop type constraints\nHUDMainMenu.propTypes = {\n    \"hasLoggedIn\": PropTypes.bool,\n    \"onSongSelectRequest\": PropTypes.func,\n    \"onLoginRequest\": PropTypes.func,\n    \"onAboutPageRequest\": PropTypes.func,\n    \"onLeaderboardsPageRequest\": PropTypes.func\n};\n\n// default properties\nHUDMainMenu.defaultProps = {\n    \"hasLoggedIn\": false,\n    \"onSongSelectRequest\": () => {\n        throw new Error(\"No handler passed.\");\n    },\n    \"onLoginRequest\": () => {\n        throw new Error(\"No handler passed.\");\n    },\n    \"onAboutPageRequest\": () => {\n        throw new Error(\"No handler passed.\");\n    },\n    \"onLeaderboardsPageRequest\": () => {\n        throw new Error(\"No handler passed.\");\n    }\n};\n\nexport default HUDMainMenu;","// key for accessing local storage data\nconst LOCAL_STORAGE_KEY = \"spotify-refresh-token\";\n\n/**\n * Either console logs or broadcasts a state message.\n *\n * @param {String} state current spotify service state\n * @param {*} body the body of the notification. Could be anything depending on the state.\n * @param {String} message optional message to be notified\n * @param {Rx.Subject} notifier the observable to emit the message from\n *\n * @returns {void}\n */\nconst log = (state, body, message = \"\", notifier = null) => {\n\n    const notification = {\n        \"source\": \"SpotifyService\",\n        state,\n        body,\n        message\n    };\n\n    // broadcast state\n    if (notifier) notifier.next(notification);\n    else console.log(notification);\n\n};\n\n/**\n * Fetches tokens from URL query and returns them in an object.\n * @returns {{accessToken: *, refreshToken: *}} object containing both tokens\n */\nconst getTokensFromQuery = () => {\n    const urlParams = new URLSearchParams(window.location.search);\n    const accessToken = urlParams.get(\"accessToken\");\n    const refreshToken = urlParams.get(\"refreshToken\");\n\n    return {\n        accessToken,\n        refreshToken\n    };\n};\n\n/**\n * Returns refresh and access tokens if a valid refresh token is found either in the query or local storage.\n * If no valid refresh token exists, returned tokens will be \"null\".\n * @param {Function} refreshTokenFunction function that fetches refresh tokens from server.\n * @param {Rx.Subject} stateNotifier an optional Subject that will be used to broadcast state of the utility\n * @returns {{accessToken: *, refreshToken: *}} object containing both tokens\n */\nconst processTokens = (refreshTokenFunction, stateNotifier = null) => {\n\n    // Handle state of SDK and user token\n    const queryTokens = getTokensFromQuery();\n\n    let accessToken = null;\n    let refreshToken = null;\n\n    // check if refresh token exists in local storage, or else check query\n    if (queryTokens.accessToken && queryTokens.refreshToken) {\n\n        // set state tokens\n        accessToken = queryTokens.accessToken;\n        refreshToken = queryTokens.refreshToken;\n\n        // update state\n        log(\"ACCESS_TOKEN_ACQUIRED\", {\n            accessToken,\n            refreshToken\n        }, \"Using tokens from query returned from server!\", stateNotifier);\n\n        // save token locally if it was found\n        localStorage.setItem(LOCAL_STORAGE_KEY, queryTokens.refreshToken);\n\n    } else {\n\n        // this is the case when query tokens don't exist\n        log(\"LOADING_TOKEN_FROM_LOCAL_STORAGE\", null, \"Spotify tokens not found in query. Looking in local storage...\", stateNotifier);\n\n        const localStorageRefreshToken = localStorage.getItem(LOCAL_STORAGE_KEY);\n\n        // if found, attempt to refresh\n        if (localStorageRefreshToken) {\n\n            log(\n            \"REFRESHING_TOKEN\",\n                null,\n                \"Spotify refresh token found in localStorage. Fetching new accessToken from server...\",\n                stateNotifier\n            );\n\n            refreshTokenFunction(localStorageRefreshToken)\n                .then(json => {\n\n                    log(\n                        \"ACCESS_TOKEN_ACQUIRED\",\n                        {\n                            \"accessToken\": json.accessToken,\n                            \"refreshToken\": localStorageRefreshToken\n                        },\n                        \"Spotify access token fetched.\",\n                        stateNotifier\n                    );\n\n                });\n\n        } else {\n\n            log(\n                \"NO_ACCESS_TOKEN\",\n                null,\n                \"No tokens found or refreshed. User must log in.\",\n                stateNotifier\n            );\n\n        }\n    }\n};\n\nexport {\n    getTokensFromQuery,\n    processTokens,\n    log\n};","import fromCDN from \"from-cdn\";\nimport Rx from \"rxjs\";\nimport {processTokens, log} from \"./SpotifyServiceTools\";\n\n// url for react debugging on node server (comment out for building in production)\nconst DEBUG_URL = \"http://localhost:8080\";\n\n\n/**\n * Service that handles client-side handling of Spotify communications.\n */\nclass SpotifyService {\n\n\t// Must have a reference to SDK so playback functions can be called.\n\tconstructor (spotifyPlayerName) {\n\n\t\t// keep track of all three initializations\n\t\tconst $cdn = new Rx.BehaviorSubject(false);\n\t\tconst $sdk = new Rx.BehaviorSubject(false);\n\t\tconst $token = new Rx.BehaviorSubject(false);\n\n\t\t/*\n\t\t * spotify service observable\n\t\t * subject that notifies of all state changes within this module.\n\t\t */\n\t\tconst $spotifyServiceStateNotifier = new Rx.ReplaySubject();\n\n\t\t// does all necessary initialization\n\t\tconst initPlayer = () => {\n\n\t\t\t// if this is running again after initialization, quit.\n\t\t\tif (this.player) return;\n\n\t\t\tconst {Player} = window.Spotify;\n\n\t\t\t/*\n\t\t\t * todo: may extract this to a separate func\n\t\t\t * Initialize player\n\t\t\t */\n\t\t\tthis.player = new Player({\n\t\t\t\t\"name\": \"tune mountain\",\n\t\t\t\t\"getOAuthToken\": callback => callback(this.accessToken),\n\t\t\t\t\"volume\": 0.5\n\t\t\t});\n\n\t\t\tthis.player.connect();\n\n\t\t\t// noinspection JSDeprecatedSymbols\n\t\t\tthis.player.addListener(\"ready\", ({device_id}) => {\n\t\t\t\tlog(\"PLAYER_READY\", `Spotify player ready to stream songs on ${device_id}`, $spotifyServiceStateNotifier);\n\t\t\t});\n\n\t\t\t// TODO: add listener for error and automatically refresh token\n\n\t\t};\n\n\t\t// only init spotify player/service once all three parts are done with their processes\n\t\t$cdn.combineLatest(\n\t\t\t$sdk,\n\t\t\t$token,\n\t\t\t(cdnLoaded, sdkLoaded, tokenLoaded) => cdnLoaded && sdkLoaded && tokenLoaded\n\t\t)\n\t\t\t.filter(isAllLoaded => isAllLoaded)\n\t\t\t.subscribe(() => {\n\t\t\t\tlog(\"LOGGED_IN\", null, \"User has logged in.\", $spotifyServiceStateNotifier);\n\t\t\t\tinitPlayer();\n\t\t\t});\n\n\t\t// process tokens and collect notifications from it\n\t\tprocessTokens(this.getNewAccessToken, $spotifyServiceStateNotifier);\n\n\t\t// save tokens when they're acquired\n        $spotifyServiceStateNotifier\n            .filter(notif => notif.state === \"ACCESS_TOKEN_ACQUIRED\")\n            .subscribe(newState => {\n\n                // get tokens from update\n                const {\n                    accessToken,\n                    refreshToken\n                } = newState.body;\n\n                this.accessToken = accessToken;\n                this.refreshToken = refreshToken;\n\n                if (accessToken && refreshToken) $token.next(true);\n                else $token.next(false);\n\n            });\n\n\t\tthis.name = spotifyPlayerName;\n\t\tthis.player = null;\n\t\tthis.spotifyStateNotifier = $spotifyServiceStateNotifier;\n\n\t\t// Load sdk, update state\n\t\tfromCDN([\"https://sdk.scdn.co/spotify-player.js\"])\n\t\t\t.then(() => {\n\t\t\t\t$cdn.next(true);\n\t\t\t});\n\n\t\twindow.onSpotifyWebPlaybackSDKReady = () => $sdk.next(true);\n\n\t\tthis.spotifyStateNotifier = $spotifyServiceStateNotifier;\n\n\t}\n\n\t/**\n\t * Getter for Rx.Subject that notifies state of this module to rest of the app.\n\t * @returns {Subject} Rx Observable that emits state updates.\n\t */\n\tget stateNotifier() {\n\t\treturn this.spotifyStateNotifier;\n\t}\n\n\t/**\n\t * Refreshes the user token.\n\t * @param {String} refreshToken refresh token received from Spotify\n\t * @returns {JSON} JSON returned from query.\n\t */\n\tgetNewAccessToken(refreshToken = null) {\n\n\t\tconst tokenToBeUsed = refreshToken ? refreshToken : this.refreshToken;\n\n\t\treturn fetch(`${DEBUG_URL ? DEBUG_URL : \"\"}/spotify-service/refresh-token/${tokenToBeUsed}`)\n\t\t\t.then(response => response.json())\n\t\t\t.catch(error => {\n\t\t\t\tconsole.error(error);\n\t\t\t});\n\n\t}\n\n\t/**\n\t * Plays/pauses playback on local spotify player.\n\t * @returns {void}\n\t */\n\ttogglePlayback() {\n\n\t\tthis.player.getCurrentState().then(state => {\n\t\t\tif (!state) {\n\t\t\t\tconsole.error(\"User is not playing music through the Web Playback SDK\");\n\n\t\t\t\tthis.play();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tcurrent_track,\n\t\t\t\t\"next_tracks\": [next_track]\n\t\t\t} = state.track_window;\n\n\t\t\tconsole.log(\"Currently Playing\", current_track);\n\t\t\tconsole.log(\"Playing Next\", next_track);\n\t\t});\n\n\t\tthis.player.togglePlay();\n\n\t}\n\n\t/**\n\t * Plays a song on the current active player with a given spotify URI.\n\t * @param {String} uri the Spotify URI of the song. Can be acquired through search params.\n\t * @returns {void}\n\t */\n\tplay(uri) {\n\n\t\tif (!this.player) throw new Error(\"Player not initialized.\");\n\n\t\tconst play = ({\n\t\t\tspotifyURI,\n\t\t\t\"playerInstance\": {\n\t\t\t\t\"_options\": {\n\t\t\t\t\tgetOAuthToken,\n\t\t\t\t\tid\n\t\t\t\t}\n\t\t\t}\n\t\t}) => {\n\t\t\tgetOAuthToken(access_token => {\n\t\t\t\tconst details = {\n\t\t\t\t\t\"method\": \"PUT\",\n\t\t\t\t\t\"headers\": {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\"Authorization\": `Bearer ${access_token}`\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (spotifyURI) {\n\t\t\t\t\tdetails.body = JSON.stringify({\"uris\": [spotifyURI]});\n\t\t\t\t}\n\n\t\t\t\tfetch(\n\t\t\t\t`https://api.spotify.com/v1/me/player/play?device_id=${id}`,\n\t\t\t\t\tdetails\n\t\t\t\t).then(() => console.log(`Success: Playing uri: ${spotifyURI}`));\n\t\t\t});\n\t\t};\n\n\t\t// run the function\n\t\tplay({\n\t\t\t\"playerInstance\": this.player,\n\t\t\t\"spotifyURI\": uri\n\t\t});\n\n\t}\n\n\t/**\n\t * Redirects application to accounts.spotify.com web page for login.\n\t * @returns {void}\n\t */\n\tlogin() {\n\n\t\tconsole.log(\"Redirecting to Spotify for authorization...\");\n\t\twindow.location = `${DEBUG_URL ? DEBUG_URL : \"\"}/spotify-service/login`;\n\n\t}\n\n\t/**\n\t * Searches spotify servers using the passed keywords in any order (without quotations on query).\n\t * Returns tracks on the State updater using the state keyword TRACKS_FETCHED; if a callback function is\n\t * passed, the returned JSON object is passed as the only argument in the callback function.\n\t *\n\t * @param {Function} callback an optional callback function whose argument will be the JSON object containing the songs\n\t * @param {...String} keywords one or more strings to be used in the query parameter.\n\t * @returns {void} return values are emitted on Subject or passed to callback\n\t */\n\tsearch(callback = null, ...keywords) {\n\n\t\t// 1: filter keywords into a query string\n\t\tlet searchQueryString = \"q=\";\n\t\tfor (let index = 0; index < keywords.length; index++) {\n\n\t\t\t// append keyword\n\t\t\tsearchQueryString += keywords[index];\n\n\t\t\t// add &20 between keywords if not last item\n\t\t\tsearchQueryString += index + 1 === keywords.length ? \"\" : \"&20\";\n\n\t\t}\n\n\t\t// other filtering parameters\n\t\tconst type = \"type=track\";\n\t\tconst limit = \"limit=8\";\n\n\t\t// 2: define GET parameters and headers\n\t\tconst url = `https://api.spotify.com/v1/search?${searchQueryString}&${type}&${limit}`;\n\t\tconst header = {\n\t\t\t\"method\": \"GET\",\n\t\t\t\"headers\": {\n\t\t\t\t\"Accept\": \"application/json\",\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Authorization\": `Bearer ${this.accessToken}`\n\t\t\t}\n\t\t};\n\n\t\t// 3: emit result in callback and subject\n\t\tfetch(url, header)\n\t\t\t.then(response => response.json())\n\t\t\t.then(json => {\n\n\t\t\t\t// emit\n\t\t\t\tlog(\n\t\t\t\t\t\"TRACKS_FETCHED\",\n\t\t\t\t\tjson,\n\t\t\t\t\t\"Choose any of these songs...\",\n\t\t\t\t\tthis.spotifyStateNotifier\n\t\t\t\t);\n\n\t\t\t\t// callback\n\t\t\t\tif (callback) callback(json);\n\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthrow new Error(err);\n\t\t\t});\n\n\t}\n\n\t// todo: GET function for fetching metadata needed for level generation\n\n}\n\nexport default SpotifyService;","import React, {Component} from \"react\";\nimport PropTypes from \"prop-types\";\nimport HUDButton, {HUDButtonTypesEnum} from \"./HUDButton\";\nimport {wordsToArray} from \"../../utils/StringTools\";\nimport \"../../css/hud/HUDSongSearch.css\";\n\nclass HUDSearchBar extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            \"value\": props.defaultTextValue\n        };\n        this.lastSubmittedValue = null;\n\n        this.autoSearchTimer = null;\n\n        // function bindings\n        this.handleChange = this.handleChange.bind(this);\n        this.handleSubmit = this.handleSubmit.bind(this);\n    }\n\n    /**\n     * Updates the text in the text box and resets the auto-search timer.\n     * @param {Event} event event of a key being pressed\n     * @returns {void}\n     */\n    handleChange(event) {\n\n        // if timer has been set, clear it and reset it.\n        if (this.autoSearchTimer) clearTimeout(this.autoSearchTimer);\n        this.autoSearchTimer = setTimeout(this.handleSubmit, 1000);\n\n        this.setState({\"value\": event.target.value});\n\n    }\n\n    /**\n     * Filters text in box into an array of words (also getting rid of illegal symbols)\n     * and runs handler function passing it such array.\n     * @returns {void}\n     */\n    handleSubmit() {\n\n        // do not search if nothing is in text box\n        if (this.state.value === \"\") return;\n\n        // only submit if the value has changed\n        if (this.state.value !== this.lastSubmittedValue) {\n\n            this.props.searchSongsWithQuery(wordsToArray(this.state.value));\n            this.lastSubmittedValue = this.state.value;\n\n        }\n\n    }\n\n    render() {\n        return(\n            <div className=\"search-bar-container\">\n                <input className=\"text-box\" type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                <HUDButton type={HUDButtonTypesEnum.ENTER}\n                           text=\"Search\"\n                           onClick={this.handleSubmit}\n                />\n            </div>\n        );\n    }\n\n}\n\n// default props\nHUDSearchBar.defaultProps = {\n    \"searchSongsWithQuery\": query => {\n        throw new Error(`Unable to search song with query ${query}. No handler passed.`);\n    },\n    \"defaultTextValue\": \"Type the name of a song...\"\n};\n\n// prop type constraints\nHUDSearchBar.propTypes = {\n    \"searchSongsWithQuery\": PropTypes.func,\n    \"defaultTextValue\": PropTypes.string\n};\n\nexport default HUDSearchBar;","/**\n * Converts a paragraph to an array of words, removing any symbols so that\n * no wacky HTTP GET requests are done to Spotify.\n *\n * @param {String} string the input string.\n * @returns {Array<String>} an array of the words passed to the function.\n */\nconst wordsToArray = string => {\n\n    // trim whitespace before and after\n    const paragraph = string.trim();\n\n    // eslint-disable-next-line require-unicode-regexp\n    const regex = /[A-Za-z0-1 ]/g;\n\n    // filter symbols\n    const letters = paragraph.match(regex);\n\n    const words = [];\n    let curWord = \"\";\n\n    // join letters and remove whitespace\n    letters.forEach((letter, index) => {\n        if (letter === \" \") {\n            if (curWord.length > 0) words.push(curWord);\n            curWord = \"\";\n        } else {\n            curWord += letter;\n            if (index + 1 === letters.length) words.push(curWord);\n        }\n    });\n\n    return words;\n\n};\n\nexport {\n    wordsToArray\n};","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"../../css/hud/SpotifySong.css\";\n\n/**\n * React element for rendering a song and handling clicks on that element to select a song.\n * @param {Object} props react properties\n * @constructor\n */\nconst SpotifySongListItem = props => {\n\n    const {\n        name,\n        id,\n        imgURL,\n        artist,\n        handleClick\n    } = props;\n\n    const renderArtistArray = arr => {\n\n        let str = \"\";\n\n        arr.forEach((artist, index) => {\n           str += artist;\n           str += index + 1 === arr.length ? \"\" : \", \";\n        });\n\n        return str;\n    };\n\n    return (\n        <div className=\"song-li-container\" onClick={() => handleClick({\n            name,\n            id,\n            imgURL,\n            artist\n        })}>\n            <img className=\"song-image\" src={imgURL}/>\n            <div className=\"song-data-container\">\n                <h1 className=\"song-name\">{name}</h1>\n                <h2 className=\"song-artist\">{renderArtistArray(artist)}</h2>\n            </div>\n        </div>\n    );\n\n};\n\nSpotifySongListItem.defaultProps = {\n    \"name\": \"No Song Name Assigned\",\n    \"id\": \"No ID Passed\",\n    \"imgURL\": \"No image URL passed\",\n    \"artist\": \"No Artist\",\n    \"handleClick\": () => {\n        throw new Error(\"No click handler passed\");\n    }\n};\n\nSpotifySongListItem.propTypes = {\n    \"name\": PropTypes.string,\n    \"id\": PropTypes.string,\n    \"imgURL\": PropTypes.string,\n    \"artist\": PropTypes.array,\n    \"handleClick\": PropTypes.func\n};\n\nexport default SpotifySongListItem;","import React, {Component} from \"react\";\nimport PropTypes from \"prop-types\";\nimport dotProp from \"dot-prop\";\nimport HUDSearchBar from \"../../components/hud/HUDSearchBar\";\nimport SpotifySongListItem from \"../../components/hud/SpotifySongListItem\";\nimport \"../../css/hud/HUDSongSearch.css\";\n\nconst MSG_IDENTIFIER = \"message\";\n\n/**\n * Component responsible for rendering a search bar, and requesting\n * the Spotify service to search for songs.\n */\nclass HUDSongSearchMenu extends Component {\n\n    constructor(props) {\n        super(props);\n\n        if (!props.spotifyService) throw new Error(\"HUDSearchMenu requires a reference to an instance of SpotifyService!\");\n\n        // save a reference to spotify service & state notifier\n        this.spotifyService = props.spotifyService;\n\n        // contains list of songs to be rendered\n        this.state = {\n            \"songList\": [],\n            \"hasSearched\": false\n        };\n\n        // bind functions\n        this.filterReceivedJSON = this.filterReceivedJSON.bind(this);\n    }\n\n    /**\n     * To be used as a callback (or subscription handler) for when a user searches\n     * for a set of keywords. This function filters the received object and strips it of\n     * unnecessary parameters.\n     *\n     * @param {Object} json the Spotify server response.\n     * @returns {void} new array of songs is updated to the state\n     */\n    filterReceivedJSON(json) {\n\n        // destructure tracks into array of items\n        const items = dotProp.get(json, \"tracks.items\");\n        if (!items) throw new Error(\"No items found in search response!\");\n\n        // for each item, collect URI, song name, artist name, album image\n        // eslint-disable-next-line max-params\n        const createTrackObject = (id, name, artist, img) => ({\n            name,\n            artist,\n            img,\n            id\n        });\n\n        const newTrackArray = items.map(item => {\n\n            const id = item.id;\n            const songName = item.name;\n            const artistNames = dotProp.get(item, \"artists\").map(artist => artist.name);\n            const imgURL = dotProp.get(item, \"album.images\")[0].url;\n\n            return createTrackObject(id, songName, artistNames, imgURL);\n\n        });\n\n        // update state with new array\n        this.setState({\n            \"songList\": newTrackArray\n        });\n\n    }\n\n    /**\n     * Parses array of songs in state and converts them into JSX elements.\n     */\n    renderSongList() {\n\n        const {songList, hasSearched} = this.state;\n\n        if (songList.length === 0 && hasSearched) {\n\n            return <h3 className={MSG_IDENTIFIER}>No songs found. Try something else.</h3>;\n\n        }\n\n        return songList.map(song => <SpotifySongListItem\n                name={song.name}\n                artist={song.artist}\n                imgURL={song.img}\n                id={song.id}\n                key={song.id}\n            />);\n\n    }\n\n    // renders a HUDSearchBar and a list of songs\n    render() {\n\n        return(\n            <div className=\"hud-song-search-outer-container\">\n                <div className=\"hud-song-search-inner-container\">\n                    <HUDSearchBar\n                        searchSongsWithQuery={input => this.spotifyService.search(this.filterReceivedJSON, input)}\n                    />\n                    {this.renderSongList()}\n                </div>\n            </div>\n        );\n    }\n\n}\n\n// default props\nHUDSongSearchMenu.defaultProps = {\n    \"spotifyService\": null,\n    \"selectSong\": song => {\n        console.error(\"Couldn't select song. No handler passed\", song);\n    }\n};\n\n// prop type constraints\nHUDSongSearchMenu.propTypes = {\n    \"spotifyService\": PropTypes.object,\n    \"selectSong\": PropTypes.func\n};\n\nexport default HUDSongSearchMenu;","import React, {Component} from \"react\";\nimport HUDMainMenu from \"./hud/HUDMainMenu\";\nimport SpotifyService from \"../utils/SpotifyService\";\nimport HUDSongSearchMenu from \"./hud/HUDSongSearchMenu\";\n\nconst APP_NAME = \"Tune Mountain\";\n\nclass App extends Component {\n\n\tconstructor(props) {\n\n\t\tsuper(props);\n\n\t\tconst spotifyService = new SpotifyService(`${APP_NAME} Web Player`);\n\t\tconst hasLoggedIn = false;\n\t\tspotifyService.stateNotifier.subscribe(state => console.log(state));\n\t\tspotifyService.stateNotifier\n\t\t\t.filter(notification => notification.state === \"LOGGED_IN\")\n\t\t\t.subscribe(() => this.setState({\"hasLoggedIn\": true}));\n\n\t\t// init player when sdk is ready\n\n\t\tthis.spotifyService = spotifyService;\n\n\t\tthis.state = {\n\t\t\thasLoggedIn,\n\t\t\t\"currentMenu\": null\n\t\t};\n\n\t}\n\n\tcomponentDidMount() {\n\n\t}\n\n\trender() {\n\n\t\treturn(\n\t\t\t<div>\n\n\t\t\t\t{this.state.currentMenu || <HUDMainMenu onLoginRequest={this.spotifyService.login}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thasLoggedIn={this.state.hasLoggedIn}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSongSelectRequest={() => this.setState({\"currentMenu\": <HUDSongSearchMenu spotifyService={this.spotifyService}/>})}\n\t\t\t\t/>}\n\n\t\t\t</div>\n\t\t);\n\n\t}\n\n}\n\nexport default App;","import React from \"react\";\nimport App from \"./pages/App\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}